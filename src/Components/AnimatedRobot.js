/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.5 scene.gltf
Author: l0wpoly (https://sketchfab.com/l0wpoly)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/robot-80a736ddac1044299b134cfcca87c7f9
Title: Robot
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { useSelector } from "react-redux";

export function AnimatedRobot(props) {
    const group = useRef();
    const {
      row,
      col,
      robotStartPosition,
      robotEndPosition,
      batteryPosition,
      obstaclePosition
    } = { ...props };
    //const [alertShown, setAlertShown] = useState(false);
    const { nodes, materials, animations } = useGLTF("./Assets/robot/scene.gltf");
    const faces = ["forward", "left", "backward", "right"];
    const { actions, names } = useAnimations(animations, group);
    const [currentIndex, setCurrentIndex] = useState(0); // Index of the current direction
    const animationDuration = 1; // Duration of each animation step in seconds
    const stepDistance = 0.01; // Distance to move in each animation step
    const [rotation, setRotation] = useState(0);
    const [isWalking, setIsWalking] = useState(false);
    const [faceIndex, setFaceIndex] = useState(0);
    const [face, setFace] = useState(faces[faceIndex]);
    const boxOffset = 5;
  

    const [position, setPosition] = useState({
      x: robotStartPosition.x - boxOffset - 0.5,
      y: 0.27,
      z: -(robotStartPosition.y - boxOffset - 0.5)
    });
    let blocklyInstruction = useSelector(
      (store) => store.blocklyInstruction.blockInstructionArray
    );
    const alertShown = useRef(false);
    const robotDirectionRef = useRef("TOP");

    useEffect(() => {
        setFace(faces[faceIndex]);
        if (faceIndex === 0) setRotation(2 * (Math.PI / 2));
        else if (faceIndex === 1) setRotation(3 * (Math.PI / 2));
        else if (faceIndex === 2) setRotation(0 * (Math.PI / 2));
        else if (faceIndex === 3) setRotation(1 * (Math.PI / 2));
    
        console.log(isWalking);
        if (isWalking) {
          actions["Take 001"].play();
        } else {
          actions["Take 001"].play();
        }
      
      }, [isWalking, faceIndex]);

    useFrame(() => {
      const mesh = group.current;
      let direction;
      // Calculate the current direction
      if (
        alertShown.current === false &&
        currentIndex <= blocklyInstruction.length - 1
      ) {
        direction = blocklyInstruction[currentIndex];
        console.log("REf--------------- ", robotDirectionRef.current);
        if (robotDirectionRef.current === "LEFT") {
          if (direction === "FORWARD") {
            if (mesh.position.x < -(boxOffset - 0.5) && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.x -= stepDistance;
            if (mesh.position.x < position.x - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x - 1 });
            }
          } else if (direction === "BACKWARD") {
            if (mesh.position.x > boxOffset - 0.5 && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.x += stepDistance;
            if (mesh.position.x > position.x + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x + 1 });
            }
          } else if (direction === "LEFT") {
            robotDirectionRef.current = "BOTTOM";
            mesh.rotation.y += Math.PI / 2;
            setCurrentIndex((prevIndex) => prevIndex + 1);
          } else if (direction === "RIGHT") {
            robotDirectionRef.current = "TOP";
            setCurrentIndex((prevIndex) => prevIndex + 1);
            mesh.rotation.y -= Math.PI / 2;
          }
        } else if (robotDirectionRef.current === "RIGHT") {
          if (direction === "FORWARD") {
            if (mesh.position.x > boxOffset - 0.5 && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.x += stepDistance;
            if (mesh.position.x > position.x + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x + 1 });
            }
          } else if (direction === "BACKWARD") {
            if (mesh.position.x < -(boxOffset - 0.5) && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.x -= stepDistance;
            if (mesh.position.x < position.x - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, x: position.x - 1 });
            }
          } else if (direction === "LEFT") {
            setCurrentIndex((prevIndex) => prevIndex + 1);
            robotDirectionRef.current = "TOP";
            mesh.rotation.y += Math.PI / 2;
          } else if (direction === "RIGHT") {
            setCurrentIndex((prevIndex) => prevIndex + 1);
            robotDirectionRef.current = "BOTTOM";
            mesh.rotation.y -= Math.PI / 2;
          }
        } else if (robotDirectionRef.current === "TOP") {
          if (direction === "FORWARD") {
            if (mesh.position.z < -boxOffset + 0.5 && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.z -= stepDistance;
            if (mesh.position.z < position.z - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z - 1 });
            }
          } else if (direction === "BACKWARD") {
            if (mesh.position.z > boxOffset - 0.5 && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.z += stepDistance;
            if (mesh.position.z > position.z + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z + 1 });
            }
          } else if (direction === "LEFT") {
            robotDirectionRef.current = "LEFT";
            mesh.rotation.y += Math.PI / 2;
            setCurrentIndex((prevIndex) => prevIndex + 1);
          } else if (direction === "RIGHT") {
            robotDirectionRef.current = "RIGHT";
            mesh.rotation.y -= Math.PI / 2;
            setCurrentIndex((prevIndex) => prevIndex + 1);
          }
        } else if (robotDirectionRef.current === "BOTTOM") {
          if (direction === "FORWARD") {
            if (mesh.position.z > boxOffset - 0.5 && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.z += stepDistance;
            if (mesh.position.z > position.z + 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z + 1 });
            }
          } else if (direction === "BACKWARD") {
            if (mesh.position.z < -boxOffset + 0.5 && !alertShown.current) {
              alertShown.current = true;
              alert("Game End");
              return;
            }
            mesh.position.z -= stepDistance;
            if (mesh.position.z < position.z - 1) {
              setCurrentIndex((prevIndex) => prevIndex + 1);
              setPosition({ ...position, z: position.z - 1 });
            }
          } else if (direction === "LEFT") {
            robotDirectionRef.current = "RIGHT";
            mesh.rotation.y -= Math.PI / 2;
            setCurrentIndex((prevIndex) => prevIndex + 1);
          } else if (direction === "RIGHT") {
            robotDirectionRef.current = "LEFT";
            mesh.rotation.y += Math.PI / 2;
            setCurrentIndex((prevIndex) => prevIndex + 1);
          }
        }
      }
  
      // Update the object's position based on the current direction
      console.log("position- ", position);
      console.log(direction);
      console.log(currentIndex);
    });
  

  return (
    <group
      ref={group}
      position={[
        robotStartPosition.x - boxOffset - 0.5,
        0.27,
        -(robotStartPosition.y - boxOffset - 0.5)
      ]}
      scale={0.5}
      rotation={[0, rotation, 0]}
      dispose={null}
    >
      <group name="Sketchfab_Scene">
        <group
          name="Sketchfab_model"
          rotation={[-Math.PI / 2, 0, 0]}
          scale={0.057}
        >
          <group
            name="edca9fd234644d5480a540acc91ca584fbx"
            rotation={[Math.PI / 2, 0, 0]}
          >
            <group name="Object_2">
              <group name="RootNode">
                <group name="Object_4">
                  <primitive object={nodes._rootJoint} />
                  <group
                    name="Object_6"
                    position={[0, 10, 0]}
                    rotation={[-Math.PI / 2, 0, 0]}
                  />
                  <group
                    name="Robo"
                    position={[0, 10, 0]}
                    rotation={[-Math.PI / 2, 0, 0]}
                  />
                  <group
                    name="Cylinder001"
                    position={[-0.121, 0, -0.603]}
                    rotation={[-Math.PI / 2, 0, 0]}
                  >
                    <mesh
                      name="Cylinder001_M_Suelo_0"
                      geometry={nodes.Cylinder001_M_Suelo_0.geometry}
                      material={materials.M_Suelo}
                    />
                  </group>
                  <skinnedMesh
                    name="Object_7"
                    geometry={nodes.Object_7.geometry}
                    material={materials.M_Metal1}
                    skeleton={nodes.Object_7.skeleton}
                  />
                  <skinnedMesh
                    name="Object_8"
                    geometry={nodes.Object_8.geometry}
                    material={materials.M_Pantalla1}
                    skeleton={nodes.Object_8.skeleton}
                  />
                  <skinnedMesh
                    name="Object_9"
                    geometry={nodes.Object_9.geometry}
                    material={materials.M_Pantalla2}
                    skeleton={nodes.Object_9.skeleton}
                  />
                  <skinnedMesh
                    name="Object_10"
                    geometry={nodes.Object_10.geometry}
                    material={materials.M_Rueda}
                    skeleton={nodes.Object_10.skeleton}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("./Assets/robot/scene.gltf");
